module Interpreter (interpret, interpretAst) where

import AbstractSyntaxTree
import Data.List (isSuffixOf)
import Parser (parse)
import Scanner (scanTokens)
import Tokens

import qualified Data.Map as Map

{- |
  'interpret' - Interprets Lox language code.

  This function takes a string of Lox source code, scans it into tokens, parses those tokens into an abstract syntax tree (AST),
  and then interprets the AST. It executes the program and collects STDOUT from any print statements encountered. If a runtime
  error occurs during interpretation, it halts execution and returns the error.

  Input:
    - 'code :: String': The source code of the Lox program to be interpreted.

  Output:
    - '(Maybe LoxRuntimeError, [String])': A tuple where the first element is `Nothing` if execution completes without errors,
      or `Just LoxRuntimeError` if a runtime error occurs. The second element is a list of strings representing the STDOUT
      generated by print statements in the code.
-}
interpret :: String -> (Maybe LoxRuntimeError, [String])
interpret code =
  let (Ast stmts) = parse . scanTokens $ code
      (maybeErr, _, prints) = interpretStmts stmts [Map.empty]
   in (maybeErr, prints)

{- |
  'interpretAst' - Interprets a Lox language AST (Abstract Syntax Tree).

  This function takes an AST representing a Lox program, interprets the AST, and executes the program. It collects STDOUT
  from any print statements encountered during execution. If a runtime error occurs during interpretation, it halts execution
  and returns the error alongside any STDOUT produced up to the point of error.

  Input:
    - 'Ast': An AST representing the Lox program to be interpreted, constructed from parsed Lox source code.

  Output:
    - '(Maybe LoxRuntimeError, [String])': A tuple where the first element is `Nothing` if execution completes without errors,
      or `Just LoxRuntimeError` if a runtime error occurs. The second element is a list of strings representing the STDOUT
      generated by print statements in the code.
-}
interpretAst :: Ast -> (Maybe LoxRuntimeError, [String])
interpretAst (Ast stmts) =
  let (maybeErr, _, prints) = interpretStmts stmts [Map.empty]
   in (maybeErr, prints)

data LoxValue
  = LoxNumber Float
  | LoxString String
  | LoxBool Bool
  | LoxNil
  deriving (Eq)

instance Show LoxValue where
  show LoxNil = "nil"
  show (LoxNumber n) =
    let text = show n
     in if ".0" `isSuffixOf` text then take (length text - 2) text else text
  show (LoxString s) = reverse s
  show (LoxBool b) = if b then "true" else "false"

data LoxRuntimeError = LoxRuntimeError String deriving (Show, Eq)

data Mutability = Mutable | Immutable deriving (Eq, Show)
type Variable = (Maybe LoxValue, Mutability)
type Environment = [Map.Map String Variable]

-- Declare a new variable or redeclare an existing one
define :: String -> Maybe LoxValue -> TokenType -> Environment -> Environment
define name value _ [] = error $ "Internal Lox Error! Tried to define '" ++ name ++ " = " ++ show value ++ "' but received empty list. This should be impossible!"
define name value CONST (current : outer) = Map.insert name (value, Immutable) current : outer
define name value _ (current : outer) = Map.insert name (value, Mutable) current : outer

-- Assign value to already existing variable.
assign :: String -> LoxValue -> Int -> Environment -> Either LoxRuntimeError Environment
assign name _ line [] = Left $ LoxRuntimeError $ "Line " ++ show line ++ ". Undefined variable '" ++ name ++ "'."
assign name value line (current : outer) =
  case Map.lookup name current of
    Just (_, Mutable) -> Right $ Map.insert name (Just value, Mutable) current : outer
    Just (Nothing, Immutable) -> Right $ Map.insert name (Just value, Immutable) current : outer
    Just (Just _, Immutable) -> Left $ LoxRuntimeError $ "Attempted to reassign constant '" ++ name ++ "'."
    Nothing -> do
      newOuter <- assign name value line outer
      Right $ current : newOuter

-- Get a variable's value, returning Either LoxRuntimeError LoxValue
getVar :: String -> Int -> Environment -> Either LoxRuntimeError Variable
getVar name line [] = Left $ LoxRuntimeError ("Line " ++ show line ++ ". Undefined variable '" ++ name ++ "'.")
getVar name line (current : outer) =
  case Map.lookup name current of
    Just variable -> Right variable
    Nothing -> getVar name line outer

{- |
  'interpretStmts' - Recursively evaluates a list of statements within a given environment,
                     capturing possible runtime errors and print outputs.

  Input:
    - 'stmts :: [Stmt]' - List of statements to interpret.
    - 'env :: Environment' - The current environment context for statement evaluation.

  Output:
    - '(Maybe LoxRuntimeError, Environment, [String])' - The output is a tuple containing
      potentially an error, the updated environment after the statement's evaluation, and
      a list of strings representing any output generated during the evaluation (e.g., by
      print statements).
-}
interpretStmts :: [Stmt] -> Environment -> (Maybe LoxRuntimeError, Environment, [String])
interpretStmts [] env = (Nothing, env, [])
interpretStmts (stmt : rest) env =
  let (err, newEnv, output) = evaluateStmt stmt env
   in case err of
        Just e -> (Just e, newEnv, output) -- Stop execution on error, but include any outputs so far.
        Nothing ->
          let (nextErr, finalEnv, outputs) = interpretStmts rest newEnv
           in (nextErr, finalEnv, output ++ outputs)

{- |
  'evaluateStmt' - Evaluates a given statement within a specific environment.

  Input:
    - 'stmt :: Stmt' - The statement to be evaluated.
    - 'env :: Environment' - The current environment in which the statement is evaluated.

  Output:
    - '(Maybe LoxRuntimeError, Environment, [String])' - The output is a tuple containing
      potentially an error, the updated environment after the statement's evaluation, and
      a list of strings representing any output generated during the evaluation (e.g., by
      print statements).
-}
evaluateStmt :: Stmt -> Environment -> (Maybe LoxRuntimeError, Environment, [String])
evaluateStmt stmt env = case stmt of
  ExprStmt expr -> evaluateExprStmt expr env
  PrintStmt expr -> evaluatePrintStmt expr env
  BlockStmt stmts -> evaluateBlockStmt stmts env
  IfStmt expr ifStmt maybeStmt -> evaluateIfStmt expr ifStmt maybeStmt env
  WhileStmt condition body -> evaluateWhileStmt condition body env
  VarDeclStmt tokenType token EmptyExpr -> evaluateVarDeclStmt tokenType token Nothing env
  VarDeclStmt tokenType token expr -> evaluateVarDeclStmt tokenType token (Just expr) env
  ErrorStmt expr -> evaluateErrorStmt expr env

evaluateExprStmt :: Expr -> Environment -> (Maybe LoxRuntimeError, Environment, [String])
evaluateExprStmt expr env =
  case evaluateExpr expr env of
    Left err -> (Just err, env, [])
    Right (newEnv, _) -> (Nothing, newEnv, [])

evaluatePrintStmt :: Expr -> Environment -> (Maybe LoxRuntimeError, Environment, [String])
evaluatePrintStmt expr env =
  case evaluateExpr expr env of
    Left err -> (Just err, env, [])
    Right (newEnv, printResult) -> (Nothing, newEnv, [show printResult])

evaluateBlockStmt :: [Stmt] -> Environment -> (Maybe LoxRuntimeError, Environment, [String])
evaluateBlockStmt stmts env = evaluateBlockStmts stmts (Map.empty : env) []
 where
  evaluateBlockStmts [] tempEnv acc = (Nothing, tail tempEnv, acc)
  evaluateBlockStmts (s : ss) tempEnv acc =
    case evaluateStmt s tempEnv of
      (Just err, envAfterEval, prints) -> (Just err, envAfterEval, prints)
      (Nothing, envAfterEval, prints) -> evaluateBlockStmts ss envAfterEval (acc ++ prints)

evaluateIfStmt :: Expr -> Stmt -> Maybe Stmt -> Environment -> (Maybe LoxRuntimeError, Environment, [String])
evaluateIfStmt expr stmt maybeStmt env =
  case evaluateExpr expr env of
    Left err -> (Just err, env, [])
    Right (newEnv, exprValue) ->
      if isTruthy exprValue
        then evaluateStmt stmt newEnv
        else case maybeStmt of
          Just elseStmt -> evaluateStmt elseStmt newEnv
          _ -> (Nothing, newEnv, [])

evaluateWhileStmt :: Expr -> Stmt -> Environment -> (Maybe LoxRuntimeError, Environment, [String])
evaluateWhileStmt condition stmt env = while env []
 where
  while env printAcc =
    case evaluateExpr condition env of
      Left err -> (Just err, env, printAcc)
      Right (envAfterCondition, val) ->
        if isTruthy val
          then case evaluateStmt stmt envAfterCondition of
            (Just err, envAfterStmt, prints) -> (Just err, envAfterStmt, printAcc ++ prints)
            (Nothing, envAfterStmt, prints) -> while envAfterStmt (printAcc ++ prints)
          else (Nothing, envAfterCondition, printAcc)

evaluateVarDeclStmt :: TokenType -> Token -> Maybe Expr -> Environment -> (Maybe LoxRuntimeError, Environment, [String])
evaluateVarDeclStmt tokenType (TOKEN _ _ (ID name) _) maybeExpr env =
  case maybeExpr of
    Nothing -> (Nothing, define name Nothing tokenType env, [])
    Just expr ->
      case evaluateExpr expr env of
        Left err -> (Just err, env, [])
        Right (newEnv, val) -> (Nothing, define name (Just val) tokenType newEnv, [])

evaluateErrorStmt :: Expr -> Environment -> (Maybe LoxRuntimeError, Environment, [String])
evaluateErrorStmt expr env = (Just $ LoxRuntimeError $ show expr, env, [])

{- |
  'evaluateExpr' - Evaluates an expression within a given environment, returning any
                   runtime error and the resulting value.

  Input:
    - 'expr :: Expr' - The expression to evaluate.
    - 'env :: Environment' - The environment context for evaluating the expression.

  Output:
    - 'Either LoxRuntimeError (Environment, LoxValue)' - Either a runtime error or the updated environment
                                                         and the value resulting from the expression evaluation.
-}
evaluateExpr :: Expr -> Environment -> Either LoxRuntimeError (Environment, LoxValue)
evaluateExpr (LiteralExpr token) env = evaluateLiteral token env
evaluateExpr (AssignExpr token expr) env = evaluateAssignment token expr env
evaluateExpr (UnaryExpr token expr) env = evaluateUnary token expr env
evaluateExpr (BinaryExpr leftExpr token rightExpr) env = evaluateBinary leftExpr token rightExpr env
evaluateExpr (GroupingExpr expr) env = evaluateExpr expr env
evaluateExpr (ErrorExpr err) _ = Left . LoxRuntimeError $ show err
evaluateExpr EmptyExpr env = Right (env, LoxNil)

evaluateLiteral :: Token -> Environment -> Either LoxRuntimeError (Environment, LoxValue)
evaluateLiteral (TOKEN _ _ literal line) env =
  case literal of
    NUM value -> Right (env, LoxNumber value)
    STR value -> Right (env, LoxString value)
    TRUE_LIT -> Right (env, LoxBool True)
    FALSE_LIT -> Right (env, LoxBool False)
    NIL_LIT -> Right (env, LoxNil)
    ID name -> do
      (result, _) <- getVar name line env
      case result of
        Just value -> Right (env, value)
        Nothing -> Left $ LoxRuntimeError $ "Tried to evaluate variable without assignment: '" ++ name ++ "'"
    _ -> Left $ LoxRuntimeError $ "Unknown literal: " ++ show literal

evaluateUnary :: Token -> Expr -> Environment -> Either LoxRuntimeError (Environment, LoxValue)
evaluateUnary token@(TOKEN unary _ _ line) expr env = do
  (envAfterRight, right) <- evaluateExpr expr env
  case (unary, right) of
    (MINUS, LoxNumber r) -> Right (envAfterRight, LoxNumber (-r))
    (BANG, _) -> Right (envAfterRight, LoxBool . not $ isTruthy right)
    _ -> Left . LoxRuntimeError $ "Line: " ++ show line ++ ". Unsupported unary operator: '" ++ show token ++ "'."

evaluateAssignment :: Token -> Expr -> Environment -> Either LoxRuntimeError (Environment, LoxValue)
evaluateAssignment (TOKEN _ _ (ID name) line) expr env = do
  (envAfterEval, newValue) <- evaluateExpr expr env
  envAfterAssign <- assign name newValue line envAfterEval
  Right (envAfterAssign, newValue)
evaluateAssignment (TOKEN _ _ literal line) _ _ =
  Left . LoxRuntimeError $ "Line: " ++ show line ++ ". Expected ID literal but got '" ++ show literal ++ "'"

evaluateBinary :: Expr -> Token -> Expr -> Environment -> Either LoxRuntimeError (Environment, LoxValue)
evaluateBinary leftExpr (TOKEN OR _ _ _) rightExpr env = do
  (envAfterLeft, leftVal) <- evaluateExpr leftExpr env
  if isTruthy leftVal
    then Right (envAfterLeft, leftVal)
    else evaluateExpr rightExpr envAfterLeft
evaluateBinary leftExpr (TOKEN AND _ _ _) rightExpr env = do
  (envAfterLeft, leftVal) <- evaluateExpr leftExpr env
  if not . isTruthy $ leftVal
    then Right (envAfterLeft, leftVal)
    else evaluateExpr rightExpr envAfterLeft
evaluateBinary leftExpr token@(TOKEN _ _ _ line) rightExpr env = do
  (envAfterLeft, leftVal) <- evaluateExpr leftExpr env
  (envAfterRight, rightVal) <- evaluateExpr rightExpr envAfterLeft
  case token of
    (TOKEN STAR _ _ _) -> case (leftVal, rightVal) of
      (LoxNumber l, LoxNumber r) -> Right (envAfterRight, LoxNumber (l * r))
      _ -> Left $ LoxRuntimeError $ "Line: " ++ show line ++ ". Binary operand '*' requires number on left and right side. Actual: " ++ show leftVal ++ " * " ++ show rightVal
    (TOKEN SLASH _ _ _) -> case (leftVal, rightVal) of
      (LoxNumber _, LoxNumber 0) -> Left $ LoxRuntimeError $ "Division by zero: " ++ show leftVal ++ " / " ++ show rightVal
      (LoxNumber l, LoxNumber r) -> Right (envAfterRight, LoxNumber (l / r))
      _ -> Left $ LoxRuntimeError $ "Line: " ++ show line ++ ". Binary operand '/' requires number on left and right side. Actual: " ++ show leftVal ++ " / " ++ show rightVal
    (TOKEN MINUS _ _ _) -> case (leftVal, rightVal) of
      (LoxNumber l, LoxNumber r) -> Right (envAfterRight, LoxNumber (l - r))
      _ -> Left $ LoxRuntimeError $ "Line: " ++ show line ++ ". Binary operand '-' requires number on left and right side. Actual: " ++ show leftVal ++ " - " ++ show rightVal
    (TOKEN PLUS _ _ _) -> case (leftVal, rightVal) of
      (LoxNumber l, LoxNumber r) -> Right (envAfterRight, LoxNumber (l + r))
      (LoxString l, LoxString r) -> Right (envAfterRight, LoxString (r ++ l))
      (LoxNumber _, _) -> Left $ LoxRuntimeError $ "Line: " ++ show line ++ ". Binary operand '+' requires number on left and right side. Actual: " ++ show leftVal ++ " + " ++ show rightVal
      (_, LoxNumber _) -> Left $ LoxRuntimeError $ "Line: " ++ show line ++ ". Binary operand '+' requires number on left and right side. Actual: " ++ show leftVal ++ " + " ++ show rightVal
      (LoxString _, _) -> Left $ LoxRuntimeError $ "Line: " ++ show line ++ ". Binary operand '+' requires string on left and right side. Actual: " ++ show leftVal ++ " + " ++ show rightVal
      (_, LoxString _) -> Left $ LoxRuntimeError $ "Line: " ++ show line ++ ". Binary operand '+' requires string on left and right side. Actual: " ++ show leftVal ++ " + " ++ show rightVal
      _ -> Left $ LoxRuntimeError $ "Line: " ++ show line ++ ". Binary operand '+' does not support: " ++ show leftVal ++ " + " ++ show rightVal
    (TOKEN EQUAL_EQUAL _ _ _) -> Right (envAfterRight, LoxBool (leftVal == rightVal))
    (TOKEN BANG_EQUAL _ _ _) -> Right (envAfterRight, LoxBool (leftVal /= rightVal))
    (TOKEN GREATER _ _ _) -> case (leftVal, rightVal) of
      (LoxNumber l, LoxNumber r) -> Right (envAfterRight, LoxBool (l > r))
      _ -> Left $ LoxRuntimeError $ "Line: " ++ show line ++ ". Binary operand '>' requires numbers on left and right side. Actual: " ++ show leftVal ++ " > " ++ show rightVal
    (TOKEN GREATER_EQUAL _ _ _) -> case (leftVal, rightVal) of
      (LoxNumber l, LoxNumber r) -> Right (envAfterRight, LoxBool (l >= r))
      _ -> Left $ LoxRuntimeError $ "Line: " ++ show line ++ ". Binary operand '>=' requires numbers on left and right side. Actual: " ++ show leftVal ++ " >= " ++ show rightVal
    (TOKEN LESS _ _ _) -> case (leftVal, rightVal) of
      (LoxNumber l, LoxNumber r) -> Right (envAfterRight, LoxBool (l < r))
      _ -> Left $ LoxRuntimeError $ "Line: " ++ show line ++ ". Binary operand '<' requires numbers on left and right side. Actual: " ++ show leftVal ++ " < " ++ show rightVal
    (TOKEN LESS_EQUAL _ _ _) -> case (leftVal, rightVal) of
      (LoxNumber l, LoxNumber r) -> Right (envAfterRight, LoxBool (l <= r))
      _ -> Left $ LoxRuntimeError $ "Line: " ++ show line ++ ". Binary operand '<=' requires numbers on left and right side. Actual: " ++ show leftVal ++ " <= " ++ show rightVal
    _ -> Left . LoxRuntimeError $ "Line: " ++ show line ++ ". Unsupported binary operator: '" ++ show token ++ "'."

isTruthy :: LoxValue -> Bool
isTruthy LoxNil = False
isTruthy (LoxBool theTruth) = theTruth
isTruthy _ = True
