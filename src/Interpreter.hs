module Interpreter (interpret, interpretAst) where

import AbstractSyntaxTree
import Data.List (isSuffixOf)
import Parser (parse)
import Scanner (scanTokens)
import Tokens

import qualified Data.Map as Map
import System.Environment (getEnvironment)

{- |
  'interpret' - Interprets Lox language code.

  This function takes a string of Lox source code, scans it into tokens, parses those tokens into an abstract syntax tree (AST),
  and then interprets the AST. It executes the program and collects STDOUT from any print statements encountered. If a runtime
  error occurs during interpretation, it halts execution and returns the error.

  Input:
    - 'code :: String': The source code of the Lox program to be interpreted.

  Output:
    - '(Maybe LoxRuntimeError, [String])': A tuple where the first element is `Nothing` if execution completes without errors,
      or `Just LoxRuntimeError` if a runtime error occurs. The second element is a list of strings representing the STDOUT
      generated by print statements in the code.
-}
interpret :: String -> (Maybe LoxRuntimeError, [String])
interpret code =
  let (Ast stmts) = parse . scanTokens $ code
      (maybeErr, _, prints) = interpretStmts stmts [Map.empty]
   in (maybeErr, prints)

{- |
  'interpretAst' - Interprets a Lox language AST (Abstract Syntax Tree).

  This function takes an AST representing a Lox program, interprets the AST, and executes the program. It collects STDOUT
  from any print statements encountered during execution. If a runtime error occurs during interpretation, it halts execution
  and returns the error alongside any STDOUT produced up to the point of error.

  Input:
    - 'Ast': An AST representing the Lox program to be interpreted, constructed from parsed Lox source code.

  Output:
    - '(Maybe LoxRuntimeError, [String])': A tuple where the first element is `Nothing` if execution completes without errors,
      or `Just LoxRuntimeError` if a runtime error occurs. The second element is a list of strings representing the STDOUT
      generated by print statements in the code.
-}
interpretAst :: Ast -> (Maybe LoxRuntimeError, [String])
interpretAst (Ast stmts) =
  let (maybeErr, _, prints) = interpretStmts stmts [Map.empty]
   in (maybeErr, prints)

data LoxValue
  = LoxNumber Float
  | LoxString String
  | LoxBool Bool
  | LoxNil
  deriving (Eq)

instance Show LoxValue where
  show LoxNil = "nil"
  show (LoxNumber n) =
    let text = show n
     in if ".0" `isSuffixOf` text then take (length text - 2) text else text
  show (LoxString s) = reverse s
  show (LoxBool b) = if b then "true" else "false"

data LoxRuntimeError = LoxRuntimeError String deriving (Show, Eq)

data Mutability = Mutable | Immutable deriving (Eq, Show)
type Variable = (Maybe LoxValue, Mutability)
type Environment = [Map.Map String Variable]

-- Declare a new variable or redeclare an existing one
define :: String -> Maybe LoxValue -> TokenType -> Environment -> Environment
define name value CONST (current : outer) = Map.insert name (value, Immutable) current : outer
define name value _ (current : outer) = Map.insert name (value, Mutable) current : outer

-- Assign value to already existing variable.
assign :: String -> LoxValue -> Environment -> Either LoxRuntimeError Environment
assign name _ [] = Left $ LoxRuntimeError $ "Undefined variable '" ++ name ++ "'."
assign name value (current : outer) =
  case Map.lookup name current of
    Just (_, Mutable) -> Right $ Map.insert name (Just value, Mutable) current : outer
    Just (Nothing, Immutable) -> Right $ Map.insert name (Just value, Immutable) current : outer
    Just (Just _, Immutable) -> Left $ LoxRuntimeError $ "Attempted to reassign constant '" ++ name ++ "'."
    Nothing -> do
      newOuter <- assign name value outer
      Right $ current : newOuter

-- Get a variable's value, returning Either LoxRuntimeError LoxValue
getVar :: String -> Environment -> Either LoxRuntimeError Variable
getVar name [] = Left $ LoxRuntimeError ("Undefined variable '" ++ name ++ "'.")
getVar name (current : outer) =
  case Map.lookup name current of
    Just variable -> Right variable
    Nothing -> getVar name outer

{- |
  'interpretStmts' - Recursively evaluates a list of statements within a given environment,
                     capturing possible runtime errors and print outputs.

  Input:
    - 'stmts :: [Stmt]' - List of statements to interpret.
    - 'env :: Environment' - The current environment context for statement evaluation.

  Output:
    - '(Maybe LoxRuntimeError, Environment, [String])' - Possible runtime error, the final getEnvironment after
    -                                                    statement evaluations, and accumulated STDOUT from prints.
-}
interpretStmts :: [Stmt] -> Environment -> (Maybe LoxRuntimeError, Environment, [String])
interpretStmts [] env = (Nothing, env, [])
interpretStmts (stmt : rest) env =
  let (err, newEnv, output) = evaluateStmt stmt env
   in case err of
        Just e -> (Just e, newEnv, output) -- Stop execution on error, but include any outputs so far.
        Nothing ->
          let (nextErr, finalEnv, outputs) = interpretStmts rest newEnv
           in (nextErr, finalEnv, output ++ outputs)

evaluateStmt :: Stmt -> Environment -> (Maybe LoxRuntimeError, Environment, [String])
evaluateStmt (ExprStmt expr) env =
  case evaluateExpr expr env of
    Left err -> (Just err, env, [])
    Right (newEnv, _) -> (Nothing, newEnv, [])
evaluateStmt (PrintStmt expr) env =
  case evaluateExpr expr env of
    Left err -> (Just err, env, [])
    Right (newEnv, printResult) -> (Nothing, newEnv, [show printResult])
evaluateStmt (BlockStmt stmts) env = evaluateBlockStmts stmts (Map.empty : env) []
 where
  evaluateBlockStmts [] tempEnv acc = (Nothing, tail tempEnv, acc)
  evaluateBlockStmts (s : ss) tempEnv acc =
    case evaluateStmt s tempEnv of
      (Just err, envAfterEval, prints) -> (Just err, envAfterEval, prints)
      (Nothing, envAfterEval, prints) -> evaluateBlockStmts ss envAfterEval (acc ++ prints)
evaluateStmt (IfStmt expr stmt maybeStmt) env =
  case evaluateExpr expr env of
    Left err -> (Just err, env, [])
    Right (newEnv, exprValue) ->
      if isTruthy exprValue
        then evaluateStmt stmt newEnv
        else case maybeStmt of
          Just elseStmt -> evaluateStmt elseStmt newEnv
          _ -> (Nothing, newEnv, [])
evaluateStmt (WhileStmt condition stmt) initialEnv = while initialEnv []
 where
  while env printAcc =
    case evaluateExpr condition env of
      Left err -> (Just err, env, printAcc)
      Right (envAfterCondition, val) ->
        if isTruthy val
          then case evaluateStmt stmt envAfterCondition of
            (Just err, envAfterStmt, prints) -> (Just err, envAfterStmt, printAcc ++ prints)
            (Nothing, envAfterStmt, prints) -> while envAfterStmt (printAcc ++ prints)
          else (Nothing, envAfterCondition, printAcc)
evaluateStmt (VarDeclStmt tokenType (TOKEN _ _ (ID name) _) EmptyExpr) env =
  (Nothing, define name Nothing tokenType env, [])
evaluateStmt (VarDeclStmt tokenType (TOKEN _ _ (ID name) _) expr) env =
  case evaluateExpr expr env of
    Left err -> (Just err, env, [])
    Right (newEnv, val) -> (Nothing, define name (Just val) tokenType newEnv, [])
evaluateStmt (ErrorStmt expr) env = (Just $ LoxRuntimeError $ show expr, env, [])

{- |
  'evaluateExpr' - Evaluates an expression within a given environment, returning any
                   runtime error and the resulting value.

  Input:
    - 'expr :: Expr' - The expression to evaluate.
    - 'env :: Environment' - The environment context for evaluating the expression.

  Output:
    - 'Either LoxRuntimeError (Environment, LoxValue)' - Either a runtime error or the updated environment
                                                         and the value resulting from the expression evaluation.
-}
evaluateExpr :: Expr -> Environment -> Either LoxRuntimeError (Environment, LoxValue)
-- GroupingExpr
evaluateExpr (GroupingExpr expr) env = evaluateExpr expr env
-- LiteralExpr
evaluateExpr (LiteralExpr (TOKEN _ _ literal _)) env =
  case literal of
    NUM value -> Right (env, LoxNumber value)
    STR value -> Right (env, LoxString value)
    TRUE_LIT -> Right (env, LoxBool True)
    FALSE_LIT -> Right (env, LoxBool False)
    NIL_LIT -> Right (env, LoxNil)
    ID name -> do
      (result, _) <- getVar name env
      case result of
        Just value -> Right (env, value)
        Nothing -> Left $ LoxRuntimeError $ "Tried to evaluate variable without assignment: '" ++ name ++ "'"
    _ -> Left $ LoxRuntimeError $ "Unknown literal: " ++ show literal
-- UnaryExpr
evaluateExpr (UnaryExpr (TOKEN unary _ _ _) expr) env = do
  (envAfterRight, right) <- evaluateExpr expr env
  case (unary, right) of
    (MINUS, LoxNumber r) -> Right (envAfterRight, LoxNumber (-r))
    (BANG, _) -> Right (envAfterRight, LoxBool . not $ isTruthy right)
-- BinaryExpr
evaluateExpr (BinaryExpr leftExpr (TOKEN OR _ _ _) rightExpr) env = do
  (envAfterLeft, leftVal) <- evaluateExpr leftExpr env
  if isTruthy leftVal
    then Right (envAfterLeft, leftVal)
    else evaluateExpr rightExpr envAfterLeft
evaluateExpr (BinaryExpr leftExpr (TOKEN AND _ _ _) rightExpr) env = do
  (envAfterLeft, leftVal) <- evaluateExpr leftExpr env
  if not . isTruthy $ leftVal
    then Right (envAfterLeft, leftVal)
    else evaluateExpr rightExpr envAfterLeft
evaluateExpr (BinaryExpr leftExpr token rightExpr) env = do
  (envAfterLeft, leftVal) <- evaluateExpr leftExpr env
  (envAfterRight, rightVal) <- evaluateExpr rightExpr envAfterLeft
  case token of
    (TOKEN STAR _ _ _) -> case (leftVal, rightVal) of
      (LoxNumber l, LoxNumber r) -> Right (envAfterRight, LoxNumber (l * r))
      _ -> Left $ LoxRuntimeError $ "Binary operand '*' requires number on left and right side. Actual: " ++ show leftVal ++ " * " ++ show rightVal
    (TOKEN SLASH _ _ _) -> case (leftVal, rightVal) of
      (LoxNumber _, LoxNumber 0) -> Left $ LoxRuntimeError $ "Division by zero: " ++ show leftVal ++ " / " ++ show rightVal
      (LoxNumber l, LoxNumber r) -> Right (envAfterRight, LoxNumber (l / r))
      _ -> Left $ LoxRuntimeError $ "Binary operand '/' requires number on left and right side. Actual: " ++ show leftVal ++ " / " ++ show rightVal
    (TOKEN MINUS _ _ _) -> case (leftVal, rightVal) of
      (LoxNumber l, LoxNumber r) -> Right (envAfterRight, LoxNumber (l - r))
      _ -> Left $ LoxRuntimeError $ "Binary operand '-' requires number on left and right side. Actual: " ++ show leftVal ++ " - " ++ show rightVal
    (TOKEN PLUS _ _ _) -> case (leftVal, rightVal) of
      (LoxNumber l, LoxNumber r) -> Right (envAfterRight, LoxNumber (l + r))
      (LoxString l, LoxString r) -> Right (envAfterRight, LoxString (r ++ l))
      (LoxNumber _, _) -> Left $ LoxRuntimeError $ "Binary operand '+' requires number on left and right side. Actual: " ++ show leftVal ++ " + " ++ show rightVal
      (_, LoxNumber _) -> Left $ LoxRuntimeError $ "Binary operand '+' requires number on left and right side. Actual: " ++ show leftVal ++ " + " ++ show rightVal
      (LoxString _, _) -> Left $ LoxRuntimeError $ "Binary operand '+' requires string on left and right side. Actual: " ++ show leftVal ++ " + " ++ show rightVal
      (_, LoxString _) -> Left $ LoxRuntimeError $ "Binary operand '+' requires string on left and right side. Actual: " ++ show leftVal ++ " + " ++ show rightVal
      _ -> Left $ LoxRuntimeError $ "Binary operand '+' does not support: " ++ show leftVal ++ " + " ++ show rightVal
    (TOKEN EQUAL_EQUAL _ _ _) -> Right (envAfterRight, LoxBool (leftVal == rightVal))
    (TOKEN BANG_EQUAL _ _ _) -> Right (envAfterRight, LoxBool (leftVal /= rightVal))
    (TOKEN GREATER _ _ _) -> case (leftVal, rightVal) of
      (LoxNumber l, LoxNumber r) -> Right (envAfterRight, LoxBool (l > r))
      _ -> Left $ LoxRuntimeError $ "Binary operand '>' requires numbers on left and right side. Actual: " ++ show leftVal ++ " > " ++ show rightVal
    (TOKEN GREATER_EQUAL _ _ _) -> case (leftVal, rightVal) of
      (LoxNumber l, LoxNumber r) -> Right (envAfterRight, LoxBool (l >= r))
      _ -> Left $ LoxRuntimeError $ "Binary operand '>=' requires numbers on left and right side. Actual: " ++ show leftVal ++ " >= " ++ show rightVal
    (TOKEN LESS _ _ _) -> case (leftVal, rightVal) of
      (LoxNumber l, LoxNumber r) -> Right (envAfterRight, LoxBool (l < r))
      _ -> Left $ LoxRuntimeError $ "Binary operand '<' requires numbers on left and right side. Actual: " ++ show leftVal ++ " < " ++ show rightVal
    (TOKEN LESS_EQUAL _ _ _) -> case (leftVal, rightVal) of
      (LoxNumber l, LoxNumber r) -> Right (envAfterRight, LoxBool (l <= r))
      _ -> Left $ LoxRuntimeError $ "Binary operand '<=' requires numbers on left and right side. Actual: " ++ show leftVal ++ " <= " ++ show rightVal
    (TOKEN OR _ _ _) ->
      if isTruthy leftVal
        then Right (envAfterRight, leftVal)
        else Right (envAfterRight, rightVal)
    (TOKEN AND _ _ _) ->
      if not $ isTruthy leftVal
        then Right (envAfterRight, leftVal)
        else Right (envAfterRight, rightVal)
    _ -> Left . LoxRuntimeError $ "Unsupported binary operator: '" ++ show token ++ "'."
-- AssignExpr
evaluateExpr (AssignExpr (TOKEN _ _ (ID name) _) expr) env = do
  (envAfterEval, newValue) <- evaluateExpr expr env
  envAfterAssign <- assign name newValue envAfterEval
  Right (envAfterAssign, newValue)
-- EmptyExpr TODO: Not sure if this is correct
evaluateExpr EmptyExpr env = Right (env, LoxNil)

isTruthy :: LoxValue -> Bool
isTruthy LoxNil = False
isTruthy (LoxBool theTruth) = theTruth
isTruthy _ = True
