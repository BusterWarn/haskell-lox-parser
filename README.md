# Haskell Lox Interpreter

This project is an implementation of the Lox interpreter, written in Haskell. The interpreter is based on the design and specifications provided in [Crafting Interpreters](https://craftinginterpreters.com/) by Bob Nystrom. The book is an excellent resource for anyone interested in learning more about interpreters, compilers, and programming languages design.

## Scanning

The first phase of the interpreter is the scanner (or lexer), which transforms the raw source code into a series of tokens. These tokens are then used by the parser to construct an abstract syntax tree (AST). In this implementation, the scanning process is handled by the `scanTokens` function.

For more detailed information about the scanning process and its role in language interpretation, refer to the [Scanning section](https://craftinginterpreters.com/scanning.html) of Crafting Interpreters.

## Parsing

The parsing phase constructs an abstract syntax tree (AST) from the list of tokens generated by the scanner. This AST represents the program's structure and is essential for understanding the syntax and semantics of the source code. Unlike the approach taken in Crafting Interpreters, where parsing and interpreting are intertwined, this implementation completes all parsing upfront.

### Limitations

This parser does not support the following features:

- Object orientation, including classes, inheritance, and related constructs, such as dot notation (e.g., `string.print()`) and dynamic scoping for methods and fields.
- `for` loops
- Functions
- Desugaring
- Static analysis, meaning type checking and ensuring that used variables have been declared

### Chapters Utilized

This implementation draws upon a comprehensive range of topics covered across several chapters of Crafting Interpreters:

- [Chapter 5: Representing Code](https://craftinginterpreters.com/representing-code.html)
- [Chapter 6: Parsing Expressions](https://craftinginterpreters.com/parsing-expressions.html#recursive-descent-parsing)
- [Chapter 7: Evaluating Expressions](https://craftinginterpreters.com/evaluating-expressions.html)
- [Chapter 8: Statements and State](https://craftinginterpreters.com/statements-and-state.html)
- [Chapter 9: Control Flow](https://craftinginterpreters.com/control-flow.html)

These chapters provide the foundation for the scanner, parser, and evaluator developed in this project.

## Interpreting

(Not yet implemented)

The final phase is the interpreter, which executes the program represented by the AST. This step involves evaluating expressions, executing statements, and managing the environment in which the code runs.

## Hooks

If you're on a Unix-like system (Linux, macOS), you can set up the `pre-push` hook with the following command:

```bash
cp pre-push .git/hooks/pre-push
chmod +x .git/hooks/pre-push
```

## Benchmarking

This project includes a comprehensive benchmarking suite powered by the [Criterion](http://hackage.haskell.org/package/criterion) library, ensuring accurate performance measurements.

Run the benchmarks with:
```shell
stack bench
```

You might have to install Criterion before like this guide says: http://www.serpentine.com/criterion/tutorial.html.
```shell
cabal update
cabal install -j --disable-tests criterion
```
